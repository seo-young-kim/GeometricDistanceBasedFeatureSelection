def eigen(X):
    X_cen = X - X.mean(axis=0)  # 평균을 0으로
    X_cov = np.dot(X_cen.T, X_cen) / 59
    #print(X_cov)
    w, v = np.linalg.eig(X_cov)
    #print('eigenvalue :', w[0])
    #print('eigenvector :\n', v[0])
    return w[0],v[0]



# I,J간의 최소 거리 구하는 distance_min 함수
def distance_min(I,J,total):
    #inter_dist
    AVG_I =I.mean(axis=0)
    AVG_J =J.mean(axis=0)
    inter = ((len(I)+len(J))/total)*np.linalg.norm(AVG_I-AVG_J)
   # print(inter)
    #eigen value, vector each class
    valueI, vectorI = eigen(I)
    valueJ, vectorJ = eigen(J)
    
    # centor of each class
    dij = AVG_J - AVG_I
    dji = AVG_I - AVG_J
    
    #cosine
    cosij = np.inner(dij,vectorI) / (np.linalg.norm(dij)*np.linalg.norm(vectorI))
    cosji = np.inner(dji,vectorJ) / (np.linalg.norm(dji)*np.linalg.norm(vectorJ))
    
    result = 0.5*(math.sqrt(valueI)*abs(cosij) + math.sqrt(valueJ)*abs(cosji))
    result = (result.item(0,0))
  #  print(result)
    return inter-result


def eval_subset(dic):
    D =0
    total = 150
    for i in range(len(dic)-1):
            D+=(len(dic[i])+len(dic[i+1]))*(distance_min(dic[i],dic[i+1],total))
    E = eveness(dic)
    return D*E


def eveness(dic):
    d = []
    for i in range(len(dic)-1):
        I=dic[i]
        J=dic[i+1]
        AVG_I =I.mean(axis=0)
        AVG_J =J.mean(axis=0)
        inter = ((len(I)+len(J))/total)*np.linalg.norm(AVG_I-AVG_J)
        d.append(inter)
    
    U=0
    avg = np.mean(d)
    
    for i in range(len(dic)-1):
        U+=abs(d[i]-avg)
        
    c =len(dic)
    U = U/ (c*(c-1)/2)
    
    return 2- (U/avg)
    
